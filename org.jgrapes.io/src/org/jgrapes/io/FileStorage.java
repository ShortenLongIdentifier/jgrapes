/*
 * JGrapes Event Driven Framework
 * Copyright (C) 2016  Michael N. Lipp
 * 
 * This program is free software; you can redistribute it and/or modify it 
 * under the terms of the GNU General Public License as published by 
 * the Free Software Foundation; either version 3 of the License, or 
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License 
 * for more details.
 * 
 * You should have received a copy of the GNU General Public License along 
 * with this program; if not, see <http://www.gnu.org/licenses/>.
 */
package org.jgrapes.io;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.channels.AsynchronousCloseException;
import java.nio.channels.AsynchronousFileChannel;
import java.nio.channels.ClosedChannelException;
import java.nio.channels.CompletionHandler;
import java.nio.file.Path;
import java.nio.file.StandardOpenOption;
import java.util.Arrays;
import java.util.Collections;
import java.util.Map;
import java.util.WeakHashMap;
import java.util.stream.Collectors;

import org.jgrapes.core.Component;
import org.jgrapes.core.Components;
import org.jgrapes.core.DefaultChannel;
import org.jgrapes.core.Channel;
import org.jgrapes.core.Event;
import org.jgrapes.core.Self;
import org.jgrapes.core.annotation.Handler;
import org.jgrapes.core.events.Stop;
import org.jgrapes.io.events.Close;
import org.jgrapes.io.events.Closed;
import org.jgrapes.io.events.Eof;
import org.jgrapes.io.events.FileOpened;
import org.jgrapes.io.events.IOError;
import org.jgrapes.io.events.OpenFile;
import org.jgrapes.io.events.Input;
import org.jgrapes.io.events.Output;
import org.jgrapes.io.util.ManagedBufferQueue;
import org.jgrapes.io.util.ManagedByteBuffer;

/**
 * A component that reads from or writes to a file.
 * 
 * @author Michael N. Lipp
 */
public class FileStorage extends Component {

	private int bufferSize;

	private Map<Channel, FileHandler> handlers = Collections
	        .synchronizedMap(new WeakHashMap<>());
	
	/**
	 * Create a new instance using the given size for the read buffers.
	 * 
	 * @param channel the component's channel. Used for sending {@link Output}
	 * events and receiving {@link Input} events 
	 * @param bufferSize the size of the buffers used for reading
	 */
	public FileStorage(Channel channel, int bufferSize) {
		super (channel);
		this.bufferSize = bufferSize;
	}

	/**
	 * Create a new instance using the default buffer size of 4096.
	 * 
	 * @param channel the component's channel. Used for sending {@link Output}
	 * events and receiving {@link Input} events 
	 */
	public FileStorage(Channel channel) {
		this(channel, 4096);
	}

	/**
	 * Opens a file using the properties of the event. All events generated by
	 * this component related to an opened file (a connection) are considered
	 * responses to the open event. They are therefore fired using the event
	 * processor from the event's connection.
	 * 
	 * @param event
	 * @throws InterruptedException
	 */
	@Handler
	public void onOpen(OpenFile event) throws InterruptedException {
		for (IOSubchannel channel : event.channels(IOSubchannel.class)) {
			if (handlers.containsKey(channel)) {
				channel.fire(new IOError(event,
				        new IllegalStateException("File is already open.")));
			} else {
				handlers.put(channel, new FileHandler(event, channel));
			}
		}
	}

	@Handler
	public void onInput(Input<ManagedByteBuffer> event) {
		for (Channel channel: event.channels()) {
			FileHandler handler = handlers.get(channel);
			if (handler != null) {
				handler.write(event);
			}
		}
	}
	
	@Handler(channels={DefaultChannel.class, Self.class})
	public void onClose(Close event) throws InterruptedException {
		for (Channel channel: event.channels()) {
			FileHandler handler = handlers.get(channel);
			if (handler != null) {
				handler.close(event);
			}
		}
	}

	@Handler
	public void onStop(Stop event) throws InterruptedException {
		while (handlers.size() > 0) {
			FileHandler handler = handlers.entrySet().iterator().next()
			        .getValue();
			handler.close(event);
		}
	}

	private class FileHandler {

		/**
		 * The write context needs to be finer grained than the general file
		 * connection context because an asynchronous write may be only
		 * partially successful, i.e. not all data provided by the write event
		 * may successfully be written in one asynchronous write invocation.
		 */
		private class WriteContext {
			public ManagedByteBuffer buffer;
			public long pos;

			public WriteContext(ManagedByteBuffer buffer, long pos) {
				this.buffer = buffer;
				this.pos = pos;
			}
		}

		private final IOSubchannel channel;
		private Path path;
		private AsynchronousFileChannel ioChannel = null;
		private ManagedBufferQueue<ManagedByteBuffer, ByteBuffer> ioBuffers;
		private long offset = 0;
		private CompletionHandler<Integer, ManagedByteBuffer> 
			readCompletionHandler = new ReadCompletionHandler();
		private CompletionHandler<Integer, WriteContext> 
			writeCompletionHandler = new WriteCompletionHandler();
		private int outstandingAsyncs = 0;
		private boolean reading = false;

		private FileHandler(OpenFile event, IOSubchannel channel)
		        throws InterruptedException {
			this.channel = channel;
			path = event.getPath();
			try {
				ioChannel = AsynchronousFileChannel
				        .open(event.getPath(), event.getOptions());
			} catch (IOException e) {
				channel.fire(new IOError(event, e));
			}
			offset = 0;
			if (Arrays.asList(event.getOptions())
			        .contains(StandardOpenOption.WRITE)) {
				// Writing to file
				reading = false;
				channel.fire(
				        new FileOpened(event.getPath(), event.getOptions()));
			} else {
				// Reading from file
				reading = true;
				ioBuffers = new ManagedBufferQueue<>(ManagedByteBuffer.class,
				        ByteBuffer.allocateDirect(bufferSize),
				        ByteBuffer.allocateDirect(bufferSize));
				ManagedByteBuffer buffer = ioBuffers.acquire();
				registerAsGenerator();
				channel.fire(
				        new FileOpened(event.getPath(), event.getOptions()));
				synchronized (ioChannel) {
					ioChannel.read(buffer.getBacking(), offset, buffer,
					        readCompletionHandler);
					outstandingAsyncs += 1;
				}
			}
		}

		private abstract class BaseCompletionHandler<C>
		        implements CompletionHandler<Integer, C> {

			@Override
			public void failed(Throwable exc, C context) {
				try {
					if (!(exc instanceof AsynchronousCloseException)) {
						channel.fire(new IOError(null, exc));
					}
				} finally {
					handled();
				}
			}

			protected void handled() {
				synchronized (ioChannel) {
					if (--outstandingAsyncs == 0) {
						ioChannel.notifyAll();
					}
				}
			}
		}

		private class ReadCompletionHandler
		        extends BaseCompletionHandler<ManagedByteBuffer> {

			@Override
			public void completed(Integer result, ManagedByteBuffer buffer) {
				try {
					if (!handlers.containsKey(channel)) {
						return;
					}
					if (result == -1) {
						channel.fire(new Eof());
						channel.fire(new Close());
						return;
					}
					channel.fire(new Output<>(buffer));
					offset += result;
					try {
						ManagedByteBuffer nextBuffer = ioBuffers.acquire();
						nextBuffer.clear();
						synchronized (ioChannel) {
							ioChannel.read(nextBuffer.getBacking(), offset,
							        nextBuffer, readCompletionHandler);
							outstandingAsyncs += 1;
						}
					} catch (InterruptedException e) {
					}
				} finally {
					handled();
				}
			}
		}

		private void write(Input<ManagedByteBuffer> event) {
			ManagedByteBuffer buffer = event.getBuffer();
			int written = buffer.remaining();
			if (written == 0) {
				return;
			}
			buffer.lockBuffer();
			synchronized (ioChannel) {
				ioChannel.write(buffer.getBacking(), offset,
				        new WriteContext(buffer, offset),
				        writeCompletionHandler);
				outstandingAsyncs += 1;
			}
			offset += written;
		}

		private class WriteCompletionHandler
		        extends BaseCompletionHandler<WriteContext> {

			@Override
			public void completed(Integer result, WriteContext context) {
				ManagedByteBuffer buffer = context.buffer;
				if (buffer.hasRemaining()) {
					ioChannel.write(buffer.getBacking(),
					        context.pos + buffer.position(),
					        context, writeCompletionHandler);
					return;
				}
				buffer.unlockBuffer();
				handled();
			}

		}

		public void close(Event<?> event) throws InterruptedException {
			try {
				synchronized (ioChannel) {
					while (outstandingAsyncs != 0) {
						ioChannel.wait();
					}
					ioChannel.close();
				}
				channel.fire(new Closed());
			} catch (ClosedChannelException e) {
			} catch (IOException e) {
				channel.fire(new IOError(event, e));
			}
			if (reading) {
				unregisterAsGenerator();
			}
			handlers.remove(channel);
		}

		/*
		 * (non-Javadoc)
		 * 
		 * @see java.lang.Object#toString()
		 */
		@Override
		public String toString() {
			StringBuilder builder = new StringBuilder();
			builder.append("FileConnection [");
			if (channel != null) {
				builder.append("channel=");
				builder.append(channel);
				builder.append(", ");
			}
			if (path != null) {
				builder.append("path=");
				builder.append(path);
				builder.append(", ");
			}
			builder.append("offset=");
			builder.append(offset);
			builder.append("]");
			return builder.toString();
		}

	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see java.lang.Object#toString()
	 */
	@Override
	public String toString() {
		StringBuilder builder = new StringBuilder();
		builder.append(Components.objectName(this));
		builder.append(" [");
		if (handlers != null) {
			builder.append(handlers.values().stream()
			        .map(c -> Components.objectName(c))
			        .collect(Collectors.toList()));
		}
		builder.append("]");
		return builder.toString();
	}
}
