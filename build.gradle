import java.util.regex.Pattern
import org.gradle.api.tasks.testing.logging.TestExceptionFormat
import org.gradle.api.tasks.testing.logging.TestLogEvent
import aQute.bnd.osgi.Processor

buildscript {
    repositories {
        jcenter()
        mavenCentral()
		maven { url "https://oss.sonatype.org/content/repositories/snapshots/" }
        maven { url 'https://jitpack.io' }
    }
    dependencies {
        classpath 'biz.aQute.bnd:biz.aQute.bnd.gradle:3.3.0'
    }
}

plugins {
	id "maven-publish"
	id "signing"
	id "org.jdrupes.mdoclet" version "1.0.3"
}

ext {
	isTravisBuild = System.getenv().get("TRAVIS") == 'true'
}

allprojects {
    repositories {
        jcenter()
        mavenCentral()
		maven { url "https://oss.sonatype.org/content/repositories/snapshots/" }
        maven { url 'https://jitpack.io' }
    }
	
	// Makes Eclipse-groovy handle *.gradle file properly
	apply plugin:'groovy'
}

subprojects {

    apply plugin: 'biz.aQute.bnd.builder'
	apply plugin: 'signing'
	apply plugin: 'maven'
	apply plugin: 'maven-publish'
	
    tasks.withType(Javadoc).all { enabled = false }

	group = 'org.jgrapes'
	
	ext.snapshot = true
	
	if (project.file("bnd.bnd").exists()) {
		// The builder plugin doesn't provide access to the bnd properties.
		// Provide workaround as properties in extra bnd
		new Processor().withCloseable { processor ->
			processor.setProperties(project.file('bnd.bnd'))
			ext.set("bnd", processor.getFlattenedProperties());
		}
		
		// Maintain the version in the bnd.bnd. Else, bndtools won't
		// generate a proper Bundle-Version header for incrementally 
		// built jars.
		version = bnd.base_version + (snapshot ? "-SNAPSHOT" : "")
	}
	
    dependencies {
        compileOnly 'org.osgi:org.osgi.annotation:6.0.0'
        testCompile 'junit:junit:4.12', 'net.jodah:concurrentunit:0.4.2'
		testCompile "org.spockframework:spock-core:1.1-groovy-2.4-rc-3"
    }

    // Configure sensible layout
    sourceSets {
        main {
            java {
                srcDir 'src'
            }
            resources {
                srcDir 'resources'
            }
        }

        test {
            java {
                srcDir 'test'
            }
			groovy {
				srcDir 'test'
			}
            resources {
                srcDir 'resources'
            }
        }
    }
    
    test {
        testLogging {
            events TestLogEvent.FAILED,
                   TestLogEvent.SKIPPED,
                   TestLogEvent.PASSED,
                   TestLogEvent.STANDARD_ERROR,
                   TestLogEvent.STANDARD_OUT

            exceptionFormat TestExceptionFormat.FULL

            showStandardStreams = true
            showExceptions = true
            showStackTraces = true
            showCauses = true
        }
		
		if (isTravisBuild) {
            maxParallelForks = 2
            maxHeapSize = '768m'
        }
    }

	// Additional jars for publishing
		
	task sourcesJar(type: Jar) {
		from sourceSets.main.allJava
		classifier "sources"
	}
	
	task javadocJar(type: Jar) {
		from (project.rootDir) {
			include 'README.md'
		}
		classifier "javadoc"
	}
	
	// MavenPublishing (new)
	
	artifacts {
		archives jar
		archives sourcesJar
		archives javadocJar
	}

	signing {
		if (project.hasProperty("signing.keyId")) {
			sign configurations.archives
		}
	}

	publishing {
		
		publications {
			mavenJava(MavenPublication) {
				artifactId = archivesBaseName
				from components.java
				artifact sourcesJar
				artifact javadocJar
				pom.packaging "jar"
				
				// Until https://github.com/gradle/gradle/issues/1232 is fixed:
				pom.withXml {
					// Generate map of resolved versions
					Map resolvedVersionMap = [:]
					Set<ResolvedArtifact> resolvedArtifacts = configurations.compile.getResolvedConfiguration().getResolvedArtifacts()
					resolvedArtifacts.each {
						ModuleVersionIdentifier mvi = it.getModuleVersion().getId();
						resolvedVersionMap.put("${mvi.getGroup()}:${mvi.getName()}", mvi.getVersion())
					}
					Set<ResolvedArtifact> testResolved = configurations.testCompile.getResolvedConfiguration().getResolvedArtifacts()
					testResolved.each {
						ModuleVersionIdentifier mvi = it.getModuleVersion().getId();
						resolvedVersionMap.put("${mvi.getGroup()}:${mvi.getName()}", mvi.getVersion())
					}
		
					// Update dependencies with resolved versions
					if (asNode().dependencies) {
						asNode().dependencies.first().each {
							def groupId = it.get("groupId").first().value().first()
							def artifactId = it.get("artifactId").first().value().first()
							it.get("version").first().value = resolvedVersionMap.get("${groupId}:${artifactId}")
						}
					}
				}
		
				def projectName = project.name
				def projectDescription = project.description
				if (projectDescription == null || projectDescription == "") {
					projectDescription = "(No description)"
				}
				pom.withXml {
					asNode().with {
						appendNode('name', projectName)
						appendNode('description', projectDescription)
						appendNode('url', 'http://mnlipp.github.io/jgrapes/')
						appendNode('scm').with {
							appendNode('url', 'scm:git@github.com:mnlipp/jgrapes.git')
							appendNode('connection', 'scm:git@github.com:mnlipp/jgrapes.git')
							appendNode('developerConnection', 'git@github.com:mnlipp/jgrapes.git')
						}
						appendNode('licenses').with {
							appendNode('license').with {
								appendNode('name', 'GPL 3.0')
								appendNode('url', 'https://www.gnu.org/licenses/gpl-3.0.en.html')
								appendNode('distribution', 'repo')
							}
						}
						appendNode('developers').with {
							appendNode('developer').with {
								appendNode('id', 'mnlipp')
								appendNode('name', 'Michael N. Lipp')
							}
						}
					}
				}
				
				if (project.hasProperty("signing.keyId")) {
					// sign the pom
					pom.withXml {
						def pomFile = file("${project.buildDir}/generated-pom.xml")
						writeTo(pomFile)
						def pomAscFile = signing.sign(pomFile).signatureFiles[0]
						artifact(pomAscFile) {
							classifier = null
							extension = 'pom.asc'
						}
						pomFile.delete()
					}
	
					// sign the artifacts
					project.tasks.signArchives.signatureFiles.each {
						artifact(it) {
							def matcher = it.file =~ /-(sources|javadoc)\.jar\.asc$/
							if (matcher.find()) {
								classifier = matcher.group(1)
							} else {
								classifier = null
							}
							extension = 'jar.asc'
						}
					}
				}
			}
		}
		repositories {
			maven {
				name "snapshot"
				url "https://oss.sonatype.org/content/repositories/snapshots/"
				credentials {
					username project.properties['sonatypeUsername'] ?: "nouser"
					password project.properties['sonatypePassword'] ?: "nopass"
				}
			}
			maven {
				name "release"
				url "https://oss.sonatype.org/service/local/staging/deploy/maven2/"
				credentials {
					username project.properties['sonatypeUsername'] ?: "nouser"
					password project.properties['sonatypePassword'] ?: "nopass"
				}
			}
		}
	}

	model {
		if (project.hasProperty("signing.keyId")) {
			tasks.publishMavenJavaPublicationToMavenLocal {
				dependsOn(project.tasks.signArchives)
			}
			tasks.publishMavenJavaPublicationToSnapshotRepository {
				dependsOn(project.tasks.signArchives)
			}
			tasks.publishMavenJavaPublicationToReleaseRepository {
				dependsOn(project.tasks.signArchives)
			}
		}
	}
	
	afterEvaluate {
		if(!project.name.startsWith("org.jgrapes")) {
			tasks.matching { it.group == "publishing" }.all {
				enabled = false
			}
		}
	}
	
}

configurations {
    javadocTaglets
}

dependencies {
    javadocTaglets "org.jdrupes.taglets:plantuml-taglet:1.0.+"
    // javadocTaglets "com.github.mnlipp:jdrupes-taglets:master-SNAPSHOT"
}

javadoc {

    options.tagletPath = configurations.javadocTaglets.files as List
    options.taglets = ["org.jdrupes.taglets.plantUml.Taglet"]

    classpath = files(subprojects.collect {project -> 
        project.sourceSets.main.compileClasspath})
    source subprojects.collect {project -> project.sourceSets.main.allJava } 
	options.addStringOption("overview", "overview.md")
	inputs.file "overview.md"
	options.addBooleanOption("linksource", true)
	options.stylesheetFile(file("stylesheet.css"))
    options.addStringOption("bottom", file("misc/javadoc.bottom.txt").text)
    options.addStringOption("link", "http://docs.oracle.com/javase/8/docs/api/")
	destinationDir = file("../jgrapes.gh-pages/javadoc")
}
